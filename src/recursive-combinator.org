#+TITLE:  recursive combinator
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+PROPERTY: tangle recursive-combinator.js

* todo
  - note parser & sa editor
  - delimited continuation
  - some array processing function as macro
  - better repl
  - replace gulp with something else
  - [maybe] match support many arguments
  - [maybe] better imperative programming support
* note

*** beware of side-effect

    - beware of side-effect such as
      pop push shift unshift
      on array
      if you pass array to sub-function
      such side-effect will destroy the array

*** beware of function interface

    - the function interface must be strict

*** asynchronous

    - asynchronous code should only be used for IO
      to express that
      the callback depends on the finishing of asynchronous IO

* helper

*** header

    #+begin_src js
    "use strict";

    const _equal = require("deep-equal");

    function equal (value1, value2) {
      return _equal(value1, value2);
    }
    #+end_src

*** basic predicate

    #+begin_src js
    function in_node () {
      return (typeof module) !== "undefined";
    }

    function in_browser () {
      return (typeof window) !== "undefined";
    }

    function function_p (value) {
      return (typeof value) === "function";
    }

    function array_p (value) {
      return Array.isArray(value);
    }

    function object_p (value) {
      return (value instanceof Object) &&
        !array_p(value) &&
        !(value === null);
    }

    function atom_p (value) {
      return !(array_p(value) || object_p(value));
    }

    function string_p (value) {
      return (typeof value) === "string";
    }
    #+end_src

*** cat

    #+begin_src js
    function cat () {
      let argument_array = [];
      for (let argument of arguments) {
        argument_array.push(argument);
      }
      console.log.apply(
        console,
        argument_array);
    }
    #+end_src

*** orz

    #+begin_src js
    function orz () {
      cat.apply(this, arguments);
      console.assert(false, "arguments");
    }

    // {
    //   orz("k1", "k2", "k3");
    // }
    #+end_src

*** asr

    #+begin_src js
    function asr () {
      console.assert.apply(console, arguments);
    }
    #+end_src

*** STACK

    #+begin_src js
    function STACK () {
      this.array = [];
    }
    STACK.prototype = {

      cursor: function () {
        return this.array.length;
      },

      set: function (index, value) {
        this.array[index] = value;
      },

      get: function (index) {
        return this.array[index];
      },

      push: function (value) {
        this.array.push(value);
      },

      pop: function () {
        return this.array.pop();
      },

      tos: function () {
        return this.array[this.array.length - 1];
      },

      push_array: function (array) {
        for (let value of array) {
          this.array.push(value);
        }
      },

      n_pop: function (n) {
        let array = [];
        while (n > 0) {
          array.push(this.array.pop());
          n = n - 1;
        }
        return array.reverse();
      },

      n_tos: function (n) {
        let array = [];
        while (n > 0) {
          array.push(this.array[this.array.length - n]);
          n = n - 1;
        }
        return array;
      },

      is_empty: function () {
        return (this.array.length === 0);
      },

    };

    {
      let testing_stack = new STACK();

      testing_stack.push(666);
      asr(testing_stack.pop() === 666);

      testing_stack.push_array([0,1,2]);
      let array = testing_stack.n_pop(3);
      asr(array[0] === 0);
      asr(array[1] === 1);
      asr(array[2] === 2);
    }
    #+end_src

* argack

  #+begin_src js
  const argack = new STACK();
  #+end_src

* retack

  #+begin_src js
  const retack = new STACK();
  #+end_src

* apply

*** apply

    #+begin_src js
    function apply (array) {
      if (array.length === 0) {
        // do nothing
      }
      else {
        retack.push(new RETACK_POINT(array));
      }
    }
    #+end_src

* eva

*** RETACK_POINT

    #+begin_src js
    function RETACK_POINT (array) {
      this.array = array;
      this.cursor = 0;
    }

    RETACK_POINT.prototype = {

      get_current_jo: function () {
        return this.array[this.cursor];
      },

      at_tail_position: function () {
        return this.cursor + 1 === this.array.length;
      },

      next: function () {
        this.cursor = 1 + this.cursor;
      },

    };
    #+end_src

*** eva

    - main loop of the retack interpreter

    - note that
      proper tail call is handled here

    - retack_point passing
      thus eva_dispatch have the current retack_point

    #+begin_src js
    function eva (array, map) {
      let base_cursor = retack.cursor();
      apply (array);
      while (retack.cursor() > base_cursor) {
        let retack_point = retack.pop();
        let jo = retack_point.get_current_jo();
        if (!retack_point.at_tail_position()) {
          retack_point.next();
          retack.push(retack_point);
        }
        eva_dispatch(jo, retack_point);
      }
    }
    #+end_src

*** eva_dispatch

    #+begin_src js
    function eva_dispatch (jo, retack_point) {
      if (function_p(jo)) {
        eva_primitive_function(jo);
      }
      else if (jo === undefined) {
        // do nothing
      }
      else {
        argack.push(jo);
      }
    }
    #+end_src

*** eva_primitive_function

    #+begin_src js
    function eva_primitive_function (jo) {
      let count_down = jo.length;
      let arg_list = [];
      while (count_down !== 0) {
        arg_list.push(argack.pop());
        count_down = count_down - 1;
      }
      arg_list.reverse();
      let result = jo.apply(this, arg_list);
      if (result !== undefined) {
        argack.push(result);
      }
    }
    #+end_src

* tes

*** tes

    #+begin_src js
    function tes (array1, array2) {
      let cursor = argack.cursor();
      eva(array1);
      let result1 = argack.n_pop(argack.cursor() - cursor);
      cursor = argack.cursor();
      eva(array2);
      let result2 = argack.n_pop(argack.cursor() - cursor);
      let success = equal(result1, result2);
      if (success) {
        // nothing
      }
      else {
        orz("- tes fail\n",
            "program1:", array1, "\n",
            "program2:", array2, "\n");
      }
    }
    #+end_src

*** test

    #+begin_src js
    tes ([
    ], [
    ]);

    tes ([
      1, 2, 3,
    ], [
      1, 2, 3,
    ]);

    tes ([
      [1, 2, 3],
    ], [
      [1, 2, 3],
    ]);

    tes ([
      [1, 2, 3],
      [1, 2, 3],
      tes,
    ],[
      [4, 5, 6],
      [4, 5, 6],
      tes,
    ]);
    #+end_src

* stack

*** basic

    #+begin_src js
    function drop (a1) {
      apply ([
      ]);
    }

    function dup (a1) {
      apply ([
        a1, a1
      ]);
    }

    function over (a1, a2) {
      apply ([
        a1, a2, a1
      ]);
    }

    function tuck (a1, a2) {
      apply ([
        a2, a1, a2
      ]);
    }

    function swap(a1, a2) {
      apply([
        a2, a1
      ]);
    }
    #+end_src

*** test

    #+begin_src js
    tes ([
      1, 2, swap,
    ], [
      2, 1,
    ]);

    tes ([
      1, 2, over,
    ], [
      1, 2, 1,
    ]);

    tes ([
      1, 2, tuck,
    ], [
      2, 1, 2,
    ]);
    #+end_src

* basic

*** number

    - note that number === all limited float number

    #+begin_src js
    function add (a, b) { return a + b; }
    function sub (a, b) { return a - b; }

    function mul (a, b) { return a * b; }
    function div (a, b) { return a / b; }
    function mod (a, b) { return a % b; }

    function pow (a, b) { return Math.pow(a, b); }
    function log (a, b) { return Math.log(a, b); }

    function abs (a) { return Math.abs(a); }
    function neg (a) { return -a; }

    function max (a, b) { return Math.max(a, b); }
    function min (a, b) { return Math.min(a, b); }
    #+end_src

*** bool

    #+begin_src js
    function anp (bool1, bool2) { return bool1 && bool2; }
    function orp (bool1, bool2) { return bool1 || bool2; }
    function nop (bool) { return !bool; }
    #+end_src

*** predicate

    #+begin_src js
    function eq   (value1, value2) { return value1 === value2; }
    function lt   (value1, value2) { return value1 <  value2 ; }
    function gt   (value1, value2) { return value1 >  value2 ; }
    function lteq (value1, value2) { return value1 <= value2 ; }
    function gteq (value1, value2) { return value1 >= value2 ; }
    #+end_src

*** test

    #+begin_src js
    tes ([
      2, 3, pow,
      8, eq,
    ], [
      true,
    ]);

    // the deep-equal
    tes ([
      2, 3, pow,
      8, equal,
    ], [
      true,
    ]);
    #+end_src

* combinator

*** ifte

    #+begin_src js
    function ifte (predicate_array, true_array, false_array) {
      eva (predicate_array);
      if (argack.pop()) {
        eva(true_array);
      }
      else {
        eva(false_array);
      }
    }
    #+end_src

*** cond

    #+begin_src js
    function cond (sequent_array) {
      let index = 0;
      while (index + 1 < sequent_array.length) {
        let antecedent = sequent_array[index];
        let succedent = sequent_array[index + 1];
        eva (antecedent);
        let result = argack.pop();
        if (result) {
          let new_retack_point = new RETACK_POINT(succedent);
          retack.push (new_retack_point);
          return;
        }
        index = 2 + index;
      }
      orz("cond fail\n",
          "sequent_array:", sequent_array);
    }
    #+end_src

*** test

    #+begin_src js
    tes ([
      [[false], [321],
       [true], [123],
      ],cond,
    ],[
      123,
    ]);
    #+end_src

*** linrec

    #+begin_src js
    function linrec (predicate_array, base_array, before_array, after_array) {
      let rec_array = [];
      rec_array.push (predicate_array);
      rec_array.push (base_array);
      rec_array.push (before_array);
      rec_array.push (after_array);
      rec_array.push (linrec);
      eva (predicate_array);
      if (argack.pop()) {
        eva (base_array);
      }
      else {
        eva (before_array);
        eva (rec_array);
        eva (after_array);
      }
    }
    #+end_src

*** test

    #+begin_src js
    // factorial
    tes ([
      6,
      [dup, 1, eq],
      [],
      [dup, 1, sub], [mul],
      linrec,
    ],[
      720,
    ]);
    #+end_src

*** binrec

    #+begin_src js
    function binrec (predicate_array, base_array, before_array, after_array) {
      let rec_array = [];
      rec_array.push (predicate_array);
      rec_array.push (base_array);
      rec_array.push (before_array);
      rec_array.push (after_array);
      rec_array.push (binrec);
      eva (predicate_array);
      if (argack.pop()) {
        eva (base_array);
      }
      else {
        eva (before_array);
        let a2 = argack.pop();
        eva (rec_array);
        argack.push (a2);
        eva (rec_array);
        eva (after_array);
      }
    }
    #+end_src

*** genrec

    #+begin_src js
    function genrec (predicate_array, base_array, before_array, after_array) {
      let rec_array = [];
      rec_array.push (predicate_array);
      rec_array.push (base_array);
      rec_array.push (before_array);
      rec_array.push (after_array);
      rec_array.push (genrec);
      eva (predicate_array);
      if (argack.pop()) {
        eva (base_array);
      }
      else {
        eva (before_array);
        argack.push (rec_array);
        eva (after_array);
      }
    }
    #+end_src

*** tailrec

    #+begin_src js
    function tailrec (predicate_array, base_array, before_array) {
      let rec_array = [];
      rec_array.push (predicate_array);
      rec_array.push (base_array);
      rec_array.push (before_array);
      rec_array.push (tailrec);
      eva (predicate_array);
      if (argack.pop()) {
        eva (base_array);
      }
      else {
        eva (before_array);
        apply (rec_array);
      }
    }
    #+end_src

*** test

    #+begin_src js
    // last
    tes ([
      [1, 2, 3, 4, 5, 6],
      [dup, length, 1, eq],
      [car],
      [cdr],
      tailrec
    ],[
      6
    ]);
    #+end_src

* number

*** number_primrec

    #+begin_src js
    function number_primrec (base_array, after_array) {
      apply ([
        [ dup, 0, eq ],
        base_array,
        [ dup, 1, sub ],
        after_array,
        linrec,
      ]);
    }
    #+end_src

*** test

    #+begin_src js
    // factorial
    tes ([
      6,
      [drop, 1],
      [mul],
      number_primrec,
    ],[
      720,
    ]);
    #+end_src

* array

*** set & get

    #+begin_src js
    function get (array, index) {
      return array[index];
    }

    function set (array, index, value) {
      // be careful about side-effect
      array[index] = value;
    }
    #+end_src

*** test

    #+begin_src js
    tes ([
      [4, 5, 6],
      dup, 0, 0, set,
      dup, 1, 1, set,
      dup, 2, 2, set,
    ],[
      [0, 1, 2],
    ]);
    #+end_src

*** length

    #+begin_src js
    function length (array) {
      return array.length;
    }
    #+end_src

*** test

    #+begin_src js
    tes ([
      [4, 5, 6], length,
    ],[
      3,
    ]);
    #+end_src

*** concat

    #+begin_src js
    function concat (array1, array2) {
      return array1.concat(array2);
    }
    #+end_src

*** test

    #+begin_src js
    tes ([
      [1, 2, 3], dup, concat,
    ],[
      [1, 2, 3, 1, 2, 3],
    ]);
    #+end_src

*** cons & car & cdr

    - for I am embeding the syntax in js
      I use js array as list
      and do not care about the time here
      if needed
      a compiled version can use true list

    #+begin_src js
    function cons (value, array) {
      let result = [];
      result.push(value);
      return result.concat(array);
    }

    function car (array) {
      return array[0];
    }

    function cdr (array) {
      let result = [];
      let index = 1;
      while (index < array.length) {
        result.push(array[index]);
        index = 1 + index;
      }
      return result;
    }
    #+end_src

*** unit

    #+begin_src js
    function unit (value) {
      let result = [];
      result.push(value);
      return result;
    }
    #+end_src

*** empty

    #+begin_src js
    function empty (array) {
      return array.length === 0;
    }
    #+end_src

*** reverse

    #+begin_src js
    function reverse (array) {
      let result = [];
      for (let element of array) {
        result.push(element);
      }
      return result.reverse();
    }
    #+end_src

*** test

    #+begin_src js
    tes ([
      [1, 2, 3],
      dup, reverse, concat,
      dup, length,
    ],[
      [1, 2, 3, 3, 2, 1],
      6,
    ]);
    #+end_src

*** array_primrec

    #+begin_src js
    function array_primrec (base_array, after_array) {
      apply ([
        [dup, empty],
        base_array,
        [dup, car, swap, cdr],
        after_array,
        linrec,
      ]);
    }
    #+end_src

*** filter

    #+begin_src js
    function filter (predicate_array) {
      apply ([
        [],
        [[over, predicate_array, apply],
         [cons],
         [swap, drop],
         ifte],
        array_primrec,
      ]);
    }
    #+end_src

*** test

    #+begin_src js
    tes ([
      [1, 2, 3, 4, 5, 6, 7, 8], [5, lt], filter
    ],[
      [1, 2, 3, 4]
    ]);
    #+end_src

*** map

    #+begin_src js
    function map (fun) {
      apply ([
        [],
        [swap, fun, apply,
         swap, cons],
        array_primrec,
      ]);
    }
    #+end_src

*** test

    #+begin_src js
    tes ([
      [1, 2, 3, 4, 5, 6, 7, 8], [5, lt], map
    ],[
      [true, true, true, true, false, false, false, false]
    ]);
    #+end_src

*** fold

    #+begin_src js
    function fold (base, binfun) {
      apply ([
        [drop, base],
        [binfun, apply],
        array_primrec
      ]);
    }
    #+end_src

*** test

    #+begin_src js
    tes ([
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0, [add], fold
    ],[
      55
    ]);
    #+end_src

* >< object

*** ya

    - massage passing

    #+begin_src js
    function ya (object, message) {
      if (function_p (object[message])) {
        let arg_length = object[message].length;
        let arg_list = [];
        while (arg_length !== 0) {
          arg_list.push (argack.pop());
          arg_length = arg_length - 1;
        }
        arg_list.reverse();
        let result = object[message].apply(object, arg_list);
        if (result !== undefined) {
          argack.push(result);
        }
      }
      else {
        argack.push (object[message]);
      }
    }
    #+end_src

*** instance_p

    - note that
      object generaters are function
      have to quote them in array to use them in 'apply'

    #+begin_src js
    function instance_p (value, fun_array) {
      let fun = fun_array[0];
      return (value instanceof fun);
    };
    #+end_src

* data

*** note

    - poor kid's poor algebraic data type in dynamic language
      without type checker
      with faked poor pattern match without named variables

    - use new DATA (...)
      to define new algebraic data

    - each argument is an array
      for example
      #+begin_src js :tangle no
      let tree = new DATA (
        ["empty"],
        ["leaf", "value"],
        ["node", self, self]
      );
      #+end_src

    - data-constructor do not check argument type at runtime

    - only the length in the declaration is used by data-constructor

    - use 'self' to declare recursive data
      for I may add runtime check support in the future

*** DATA

    #+begin_src js
    function self () {
      orz("this function is used as unique id");
    }

    function DATA () {
      let constructor_array = [];
      for (let argument of arguments) {
        constructor_array.push(argument);
      }
      this.constructor_array = constructor_array;
      for (let constructor of constructor_array) {
        if (constructor.length === 1) {
          this[constructor[0]] = () => {
            return [this, constructor[0]];
          };
        }
        else if (constructor.length === 2) {
          this[constructor[0]] = (a1) => {
            return [this, constructor[0], a1];
          };
        }
        else if (constructor.length === 3) {
          this[constructor[0]] = (a1, a2) => {
            return [this, constructor[0], a1, a2];
          };
        }
        else if (constructor.length === 4) {
          this[constructor[0]] = (a1, a2, a3) => {
            return [this, constructor[0], a1, a2, a3];
          };
        }
        else if (constructor.length === 5) {
          this[constructor[0]] = (a1, a2, a3, a4) => {
            return [this, constructor[0], a1, a2, a3, a4];
          };
        }
        else if (constructor.length === 6) {
          this[constructor[0]] = (a1, a2, a3, a4, a5) => {
            return [this, constructor[0], a1, a2, a3, a4, a5];
          };
        }
        else if (constructor.length === 7) {
          this[constructor[0]] = (a1, a2, a3, a4, a5, a6) => {
            return [this, constructor[0], a1, a2, a3, a4, a5, a6];
          };
        }
        else {
          orz("DATA fail on constructor:", constructor);
        }
      }
    }
    #+end_src

*** match

    - no chech on length of input array

    #+begin_src js
    function match (value, pattern) {
      let type = car(pattern);
      let pattern_array = cdr(pattern);
      if (!array_p(value)) {
        orz("match fail\n",
            "value is not array:", value);
      }
      if (value.length < 1) {
        orz("match fail\n",
            "value is not a taged data:", value);
      }
      if (value[0] === type) {
        for (let clause of pattern_array) {
          if (value[1] === clause[0]) {
            argack.push_array(cdr(cdr(value)));
            apply(clause[1]);
            return;
          }
        }
        orz("match fail\n",
            "can not match value:", value, "\n",
            "with pattern:", pattern);
      }
      else {
        orz("match fail\n",
            "value:", value, "\n",
            "is not of type:", type);
      }
    }
    #+end_src

*** test

    #+begin_src js
    {
      let tree = new DATA (
        ["empty"],
        ["leaf", "value"],
        ["node", self, self]
      );

      function depth () {
        apply ([
          [tree,
           ["empty", [0]],
           ["leaf", [drop, 1]],
           ["node", [depth, swap, depth,
                     max, 1, add]],
          ],match
        ]);
      }

      tes ([
        1, tree.leaf,
        1, tree.leaf, tree.node,
        1, tree.leaf, tree.node,
        depth
      ],[
        3
      ]);
    }
    #+end_src

*** data_member_p

    #+begin_src js
    function data_member_p (value, data) {
      apply ([
        [[data, [DATA], instance_p, nop], [false],
         [value, array_p, nop], [false],
         [value, length, 1, lt], [false],
         [true], [value, car, data, eq],
        ],cond
      ]);
    }
    #+end_src

*** test

    #+begin_src js
    {
      let tree = new DATA (
        ["empty"],
        ["leaf", "value"],
        ["node", self, self]
      );

      tes ([
        1, tree.leaf,
        tree, data_member_p,
        ["string"],
        tree, data_member_p,
      ],[
        true,
        false,
      ]);
    }
    #+end_src

*** match_p

    #+begin_src js
    function match_p (value, data, constructor_string) {
      apply ([
        [value, data, data_member_p],
        [value, cdr, car, constructor_string, eq],
        [false],
        ifte,
      ]);
    }
    #+end_src

*** test

    #+begin_src js
    {
      let tree = new DATA (
        ["empty"],
        ["leaf", "value"],
        ["node", self, self]
      );

      tes ([
        1, tree.leaf,
        tree, "leaf", match_p,
      ],[
        true,
      ]);
    }
    #+end_src

*** decons

    #+begin_src js
    function decons (array) {
      let value_array = cdr (cdr (array));
      argack.push_array (value_array);
      return;
    }
    #+end_src

*** test

    #+begin_src js
    {
      let tree = new DATA (
        ["empty"],
        ["leaf", "value"],
        ["node", self, self]
      );

      function depth () {
        apply ([
          [[dup, tree, "empty", match_p],
           [drop, 0],
           [dup, tree, "leaf", match_p],
           [drop, 1],
           [dup, tree, "node", match_p],
           [decons,
            depth, swap, depth,
            max, 1, add],
          ],cond
        ]);
      }

      tes ([
        1, tree.leaf,
        1, tree.leaf, tree.node,
        1, tree.leaf, tree.node,
        depth
      ],[
        3
      ]);
    }
    #+end_src

*** >< matchgenrec

    #+begin_src js :tangle no
    function matchgenrec () {

    }
    #+end_src

*** >< CLASS

    #+begin_src js :tangle no
    {
      let maybe = new DATA (
        ["just", "value"],
        ["nothing"]
      );

      let list = new DATA (
        ["head", "value"],
        ["tail", self]
      );

      let functor = new CLASS (
        ["map", () => {}],
        ["map", () => {}]
      );
    }
    #+end_src

* list

*** list

    #+begin_src js
    let list = new DATA (
      ["empty"],
      ["node", self, "value"]
    );
    #+end_src

*** test

    #+begin_src js
    {
      function length () {
        apply ([
          [list,
           ["empty", [0]],
           ["node", [drop, length, 1, add]],
          ],match
        ]);
      }

      tes ([
        list.empty,
        1, list.node,
        2, list.node,
        3, list.node,
        length
      ],[
        3
      ]);
    }
    #+end_src

*** list.associate

    #+begin_src js
    list.associate = function recur (list1, key, equality) {
      apply ([
        list1,
        [list,
         ["empty", [false]],
         ["node", [
           [dup, car, key, equality, apply],
           [swap, drop],
           [drop, key, equality, recur],
           ifte]],
        ],match
      ]);
    };
    #+end_src

*** test

    #+begin_src js
    tes ([
      list.empty,
      [1,"k1"], list.node,
      [2,"k2"], list.node,
      [3,"k3"], list.node,
      dup,
      4, [eq], list.associate,
      swap,
      2, [eq], list.associate,
    ],[
      false,
      [2,"k2"],
    ]);
    #+end_src

* >< rbtree
* >< string

*** empty_string

    #+begin_src js

    #+end_src

* >< line & text & sexp

*** note

    - string expression using array
      mimic symbol expression using list

*** LINE

    - string
      without line break
      with line number
      line number start from 1

    #+begin_src js

    #+end_src

*** TEXT

    - line array

    #+begin_src js

    #+end_src

*** BLOCK

    - a block of indented text

    #+begin_src js

    #+end_src

*** BLOCK_STREAM

*** head_block

*** tail_block

*** block_stream_to_sexp_array

*** block_to_sexp

*** test

    #+begin_src cicada-language :tangle no
    * k1
      - c11
        ...
      * k2
        - c21
          ...
      - c12
    #+end_src

*** test

    #+begin_src js :tangle no
    ["*", "k1",
     ["-", ["c11", "..."]],
     ["*", "k2",
      ["-", ["c21", "..."]]],
     ["-", ["c12"]]];
    #+end_src

* note

*** separate namespace

    - implemented by HASH_TABLE

*** TYPE

    - TYPE is the universe set
      everything is element of this set

    - a type is a named subset of TYPE
      declared with some element constructors
      element constructors have the type in succedent

    - thus
      one can use those element constructors
      to construct element of this type

    - element constructors are trivially reverse-able function
      implemented by add a tag to its argument
      for it is reverse-able
      it can be used in pattern match
      to make branches in function body

*** algebraic data type

    - 想要設計一個 algebraic data type 的時候
      就想它的 data constructors 是什麼

    - sequent 的 constructor 有
      1. data
      2. arrow [sequent] [sequent]
      3. or [sequent]
      是否要加上 variable 呢
      區別是 variable 的出現方式是受限制的
      所以也許應該另行處理
      global-name 和 local-name 又不一樣

    - 現在只要再想好如何實現 type 就行了
      首先只處理 algebraic data type

*** sequent

    - the main type 'sequent' should be handled in cicada
      also need the 'list' to help it

    - we also need 'type'
      first I simply do 'type' : 'type'
      - to get_type
      and see what we can get

    - 'list' & 'sequent' are two types
      first needed to be stored in name_hash_table

    - in every name there are
      1. type
      2. data

* >< sequent

*** HASH_TABLE

    - index of hash-table is used as interned string

    - an entry can be viewed
      1. as a point
      2. as an orbit

    - open addressing
      for we do not need to delete

    #+begin_src js
    function HASH_TABLE_ENTRY (index) {
      this.index = index;
      this.key = null;
      this.value = null;
      this.orbit_length = 0;
      this.orbiton = 0;
    }

    HASH_TABLE_ENTRY.prototype = {

      occured: function () {
        return this.key !== null;
      },

      used: function () {
        return this.value !== null;
      },

      no_collision: function () {
        return this.index === this.orbiton;
      },

    };

    function HASH_TABLE (size, key_equal, hash) {
      this.size = size;
      this.key_equal = key_equal;
      this.hash = hash;
      this.array = new Array(this.size);
      this.counter = 0;
      let i = 0;
      while (i < this.size) {
        this.array[i] = new HASH_TABLE_ENTRY(i);
        i = 1 + i;
      }
    }

    HASH_TABLE.prototype = {

      insert: function (key) {
        // key -> index
        //     -> null -- denotes the hash_table is filled
        let orbit_index = this.hash(key, 0);
        let counter = 0;
        while (true) {
          let index = this.hash(key, counter);
          let entry = this.index_to_entry(index);
          if (!entry.occured()) {
            entry.key = key;
            entry.orbiton = orbit_index;
            let orbit_entry = this.index_to_entry(orbit_index);
            orbit_entry.orbit_length = 1 + counter;
            this.counter = 1 + this.counter;
            return index;
          }
          else if (this.key_equal(key, entry.key)) {
            return index;
          }
          else if (counter === this.size) {
            return null;
          }
          else {
            counter = 1 + counter;
          }
        }
      },

      search: function (key) {
        // key -> index
        //     -> null -- denotes key not occured
        let counter = 0;
        while (true) {
          let index = this.hash(key, counter);
          let entry = this.index_to_entry(index);
          if (!entry.occured()) {
            return null;
          }
          else if (this.key_equal(key, entry.key)) {
            return index;
          }
          else if (counter === this.size) {
            return null;
          }
          else {
            counter = 1 + counter;
          }
        }
      },

      key_to_index: function (key) {
        let index = this.insert(key);
        if (index !== null) {
          return index;
        }
        else {
          console.log("hash_table is filled");
          throw "hash_table is filled";
        }
      },

      index_to_entry: function (index) {
        return this.array[index];
      },

      key_to_entry: function (key) {
        return index_to_entry(key_to_index(key));
      },

      set: function (index, value) {
        this.index_to_entry(index).value = value;
      },

      get: function  (index) {
        return this.index_to_entry(index).value;
      },

      report_orbit: function (index, counter) {
        let entry = this.index_to_entry(index);
        while (counter < entry.orbit_length) {
          let key = entry.key;
          let next_index = this.hash(key, counter);
          let next_entry = this.index_to_entry(next_index);
          if (index === next_entry.orbiton) {
            cat("  - ", next_index, " ",
                next_entry.key);
          }
          counter = 1 + counter;
        }
      },

      report: function () {
        console.log("\n");
        console.log("- hash_table_table report_used");
        let index = 0;
        while (index < this.size) {
          let entry = this.index_to_entry(index);
          if (entry.occured() && entry.no_collision()) {
            cat("  - ", index, " ",
                entry.key, " // ",
                entry.orbit_length);
            if (entry.used()) {
              cat("      ", entry.value);
            }
            this.report_orbit(index, 1);
          }
          index = 1 + index;
        }
        cat("\n");
        cat("- used : ", this.counter);
        cat("- free : ", this.size - this.counter);
      },

    };
    #+end_src

*** name_hash_table

***** string_to_sum

      #+begin_src js
      function string_to_sum (string) {
        let sum = 0;
        let max_step = 10;
        let i = 0;
        while (i < string.length) {
          sum = sum +
            string.codePointAt(i) *
            (2 << Math.min(i, max_step));
          i = 1 + i;
        }
        return sum;
      }
      #+end_src

***** tag_hash_table

      #+begin_src js
      const tag_hash_table = new HASH_TABLE (
        // prime table size
        997,
        // key_equal
        function (key1, key2) {
          return key1 === key2;
        },
        // hash
        function (key, counter) {
          return (counter + string_to_sum(key)) % 997;
        }
      );
      #+end_src

***** test

      #+begin_src js
      {
        let index = tag_hash_table.key_to_index("testkey0");
        let key = tag_hash_table.index_to_entry(index).key;
        asr(key === "testkey0");
        // tag_hash_table.report();
      }
      #+end_src

***** helper name_hash_table

      #+begin_src js
      function array_equal (a, b) {
        if (a === b) {
          return true;
        }
        if ((a === null) || (b === null)) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        let i = 0;
        while (i < a.length) {
          if (a[i] !== b[i]) {
            return false;
          }
          i = 1 + i;
        }
        return true;
      }

      function array_remove_dup (orig_array) {
        let array = orig_array.map((element) => { return element; });
        array.sort();
        let result = [];
        let i = 0;
        while (i < array.length) {
          if (result[result.length - 1] === array[i]) {
            // do nothing
          }
          else {
            result.push(array[i]);
          }
          i = 1 + i;
        }
        return result;
      }

      function array_remove (array, value) {
        let result = [];
        for (let element of array) {
          if (element === value) {
            // do nothing
          }
          else {
            result.push(element);
          }
        }
        return result;
      }
      #+end_src

***** name_hash_table

      #+begin_src js
      const name_hash_table = new HASH_TABLE (
        // prime table size
        997,
        // key_equal
        function (key1, key2) {
          return array_equal (
            array_remove_dup(key1),
            array_remove_dup(key2));
        },
        // hash
        function (key, counter) {
          let sum = array_remove_dup(key)
              .map(string_to_sum)
              .reduce((sum, v) => { return sum + v; });
          return (counter + sum) % 997;
        }
      );
      #+end_src

***** name

      #+begin_src js
      function string_to_key (string) {
        return array_remove(string.split(":"), "");
      }

      function key_to_string (key) {
        let result = "";
        for (let element of key) {
          result = result.concat(":", element);
        }
        return result.substring(1);
      }

      function name (string) {
        return name_hash_table.key_to_index(string_to_key(string));
      }

      function name_to_string (name) {
        return key_to_string(name_hash_table.index_to_entry(name).key);
      }
      #+end_src

***** test

      #+begin_src js
      {
        name("testkey0");
        name("testkey1");
        name("testkey2");
        name("testkey3");
        name("testkey4");
        name("testkey1:testkey2:testkey3");
        name(":::testkey1:testkey2:testkey3");
        name("testkey1:testkey2");
        name("testkey4:testkey4:testkey1");
        name("testkey4:testkey1");

        asr(name_hash_table.get(name("k1")) === null);

        name_hash_table.set(name("k1:k1:k1"), 1);
        asr(name_hash_table.get(name("k1")) === 1);

        name_hash_table.set(name("k1:k1:k1"), { k1: 1 });
        asr(equal(
          name_hash_table.get(name("k1")),
          { k1: 1 }
        ));

        name_hash_table.set(name("k1:k1:k1"), null);
        asr(name_hash_table.get(name("k1")) === null);

        // name_hash_table.report();
      }
      #+end_src

*** lit

    - data are such thing like
      ["type-name", "constructor-name", ...]
      for example
      ["sequent", "arrow", [...], [...]]

    - lit("type-name", "constructor-name", ...)
      [name("type-name"), name("constructor-name"), ...]

    #+begin_src js
    function lit (array) {
      let result = [];
      for (let element of array) {
        if (string_p (element)) {
          result.push(name(element));
        }
        else if (array_p(element)) {
          result.push(lit(element));
        }
        else {
          orz ("- lit\n",
               "  can not handle element:", element ,"\n",
               "  in array:", array, "\n");
        }
      }
      return result;
    }
    #+end_src

*** test

    #+begin_src js
    // {
    //   cat (
    //     lit(
    //       ["list", "cons", ["number", "1"],
    //        ["list", "cons", ["number", "2"],
    //         ["list", "cons", ["number", "3"],
    //          ["list", "null"]]]]
    //     )
    //   );
    // }
    #+end_src

*** def & ref & reftype

    #+begin_src js
    function def (string, type, data) {
      name_hash_table.set(
        name(string),
        {
          type: type,
          data: data
        }
      );
    }

    function ref (string) {
      return name_hash_table.get(
        name(string)
      ).data;
    }

    function reftype (string) {
      return name_hash_table.get(
        name(string)
      ).type;
    }
    #+end_src

*** test

    #+begin_src js
    {
      def (
        "type",
        name("type"),
        name("type")
      );

      asr(ref("type") === name("type"));
      asr(reftype("type") === name("type"));
    }
    #+end_src

*** def type

    #+begin_src js
    def (
      "type",
      lit (["type", "type", "type"]),
      lit (["type", "type", "type"])
    );
    #+end_src

*** note sequent & quote & or

    - lit (["sequent", [...], [...]])
      lit (["quote", [...], [...]])
      lit (["or", [...]])

*** uni

    #+begin_src js
    function uni () {

    }
    #+end_src

*** cut

    #+begin_src js
    // seq data env -> seq env
    function cut (seq, data, env) {
      apply ([
        [[data, car, "sequent", name, eq],
         [[[],[],
           [],[],
          ],cond],

         [true],
         [seq,  env],

        ],cond
      ]);
    }
    #+end_src

*** >< get_type

    #+begin_src js :tangle no

    #+end_src

*** >< check

    #+begin_src js :tangle no

    #+end_src

* repl

*** argack.print

    #+begin_src js
    argack.print = function () {
      let index = 0;
      let arg_list = [];
      while (index < argack.cursor()) {
        arg_list.push (argack.array[index]);
        index = 1 + index;
      }
      cat("------", argack.cursor(), "------");
      for (let arg of arg_list) {
        cat (arg);
      }
      cat("---------------\n");
    };
    #+end_src

*** repl

    #+begin_src js
    function repl (array, map) {
      let base_cursor = retack.cursor();
      apply (array);
      while (retack.cursor() > base_cursor) {
        let retack_point = retack.pop();
        let jo = retack_point.get_current_jo();
        if (!retack_point.at_tail_position()) {
          retack_point.next();
          retack.push(retack_point);
        }
        eva_dispatch(jo, retack_point);
        argack.print();
      }
    }
    #+end_src

*** test

    #+begin_src js
    // {
    //   repl ([
    //     [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    //     0, [add], fold,
    //   ]);
    // }
    #+end_src

* exports

  #+begin_src js
  // module.exports = {
  // };
  #+end_src
