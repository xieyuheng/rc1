// Generated by CoffeeScript 1.10.0
(function() {
  var HASH_TABLE, HASH_TABLE_ENTRY, RETACK_POINT, STACK, abs, add, anp, antecedent_actual_length, apply, argack, array_p, asr, atom_p, call_with_indentation, cat, cat_get_indentation_array, cat_indentation, concat, cond, div, drop, dup, eq, eva, eva_dispatch, eva_into, eva_out, eva_primitive_function, eva_with_map, function_p, get, gt, gteq, guard, in_browser, in_node, incat, into, length, log, lt, lteq, map, match, max, min, mod, mul, neg, nop, object_p, orp, orz, out, over, pow, retack, reverse, sad, set, string_p, sub, swap, tuck, unify, unify_array, unify_dispatch, va, ya;

  in_node = function() {
    return typeof module !== "undefined";
  };

  in_browser = function() {
    return typeof window !== "undefined";
  };

  function_p = function(value) {
    return typeof value === "function";
  };

  array_p = function(value) {
    return Array.isArray(value);
  };

  object_p = function(value) {
    return (value instanceof Object) && (!(array_p(value))) && (!(value === null));
  };

  atom_p = function(value) {
    return !(array_p(value) || object_p(value));
  };

  string_p = function(value) {
    return typeof value === "string";
  };

  cat_indentation = 0;

  cat_get_indentation_array = function() {
    var i, result;
    result = [];
    i = 0;
    while (i < cat_indentation) {
      result.push(" ");
      i = 1 + i;
    }
    return result;
  };

  cat = function() {
    var argument, argument_array, j, len;
    argument_array = [];
    for (j = 0, len = arguments.length; j < len; j++) {
      argument = arguments[j];
      argument_array.push(argument);
    }
    if (in_node()) {
      return console.log.apply(console, cat_get_indentation_array().concat(argument_array));
    } else if (in_browser()) {
      return console.log.apply(console, argument_array);
    } else {
      return console.log.apply(console, cat_get_indentation_array().concat(argument_array));
    }
  };

  call_with_indentation = function(fun) {
    if (in_node()) {
      cat_indentation = 1 + cat_indentation;
      fun.call(this);
      return cat_indentation = cat_indentation - 1;
    } else if (in_browser()) {
      console.group();
      fun.call(this);
      return console.groupEnd();
    } else {
      cat_indentation = 1 + cat_indentation;
      fun.call(this);
      return cat_indentation = cat_indentation - 1;
    }
  };

  incat = function() {
    return call_with_indentation(function() {
      return cat.apply(this, arguments);
    });
  };

  orz = function() {
    cat.apply(this, arguments);
    return console.assert(false);
  };

  asr = function() {
    return console.assert.apply(console, arguments);
  };

  STACK = (function() {
    function STACK() {
      this.array = [];
    }

    STACK.prototype.cursor = function() {
      return this.array.length;
    };

    STACK.prototype.set = function(index, value) {
      return this.array[index] = value;
    };

    STACK.prototype.get = function(index) {
      return this.array[index];
    };

    STACK.prototype.push = function(value) {
      return this.array.push(value);
    };

    STACK.prototype.pop = function() {
      return this.array.pop();
    };

    STACK.prototype.tos = function() {
      return this.array[this.array.length - 1];
    };

    STACK.prototype.push_array = function(array) {
      var j, len, results, value;
      results = [];
      for (j = 0, len = array.length; j < len; j++) {
        value = array[j];
        results.push(this.array.push(value));
      }
      return results;
    };

    STACK.prototype.n_pop = function(n) {
      var array;
      array = [];
      while (n > 0) {
        array.push(this.array.pop());
        n = n - 1;
      }
      return array.reverse();
    };

    STACK.prototype.n_tos = function(n) {
      var array;
      array = [];
      while (n > 0) {
        array.push(this.array[this.array.length - n]);
        n = n - 1;
      }
      return array;
    };

    STACK.prototype.is_empty = function() {
      return this.array.length === 0;
    };

    STACK.prototype.print = function() {
      var arg_list, index;
      index = 0;
      arg_list = [];
      while (index < this.cursor()) {
        arg_list.push(this.array[index]);
        index = 1 + index;
      }
      arg_list.unshift("  *", this.cursor(), "*  --");
      arg_list.push("--");
      return console.log.apply(console, arg_list);
    };

    return STACK;

  })();

  (function() {
    var array, testing_stack;
    testing_stack = new STACK();
    testing_stack.push(666);
    asr(testing_stack.pop() === 666);
    testing_stack.push_array([0, 1, 2]);
    array = testing_stack.n_pop(3);
    asr(array[0] === 0);
    asr(array[1] === 1);
    return asr(array[2] === 2);
  })();

  HASH_TABLE_ENTRY = (function() {
    function HASH_TABLE_ENTRY(index1) {
      this.index = index1;
      this.key = null;
      this.value = null;
      this.orbit_length = 0;
      this.orbiton = 0;
    }

    HASH_TABLE_ENTRY.prototype.occured = function() {
      return this.key !== null;
    };

    HASH_TABLE_ENTRY.prototype.used = function() {
      return this.value !== null;
    };

    HASH_TABLE_ENTRY.prototype.no_collision = function() {
      return this.index === this.orbiton;
    };

    return HASH_TABLE_ENTRY;

  })();

  HASH_TABLE = (function() {
    function HASH_TABLE(size, key_equal, hash) {
      var i;
      this.size = size;
      this.key_equal = key_equal;
      this.hash = hash;
      this.array = new Array(this.size);
      this.counter = 0;
      i = 0;
      while (i < this.size) {
        this.array[i] = new HASH_TABLE_ENTRY(i);
        i = 1 + i;
      }
    }

    HASH_TABLE.prototype.insert = function(key) {
      var counter, entry, index, orbit_entry, orbit_index;
      orbit_index = this.hash(key, 0);
      counter = 0;
      while (true) {
        index = this.hash(key, counter);
        entry = this.index_to_entry(index);
        if (!entry.occured()) {
          entry.key = key;
          entry.orbiton = orbit_index;
          orbit_entry = this.index_to_entry(orbit_index);
          orbit_entry.orbit_length = 1 + counter;
          this.counter = 1 + this.counter;
          return index;
        } else if (this.key_equal(key, entry.key)) {
          return index;
        } else if (counter === this.size) {
          return null;
        } else {
          counter = 1 + counter;
        }
      }
    };

    HASH_TABLE.prototype.search = function(key) {
      var counter, entry, index;
      counter = 0;
      while (true) {
        index = this.hash(key, counter);
        entry = this.index_to_entry(index);
        if (!entry.occured()) {
          return null;
        } else if (this.key_equal(key, entry.key)) {
          return index;
        } else if (counter === this.size) {
          return null;
        } else {
          counter = 1 + counter;
        }
      }
    };

    HASH_TABLE.prototype.key_to_index = function(key) {
      var index;
      index = this.insert(key);
      if (index !== null) {
        return index;
      } else {
        console.log("hash_table is filled");
        throw "hash_table is filled";
      }
    };

    HASH_TABLE.prototype.index_to_entry = function(index) {
      return this.array[index];
    };

    HASH_TABLE.prototype.key_to_entry = function(key) {
      return index_to_entry(key_to_index(key));
    };

    HASH_TABLE.prototype.report_orbit = function(index, counter) {
      var entry, key, next_entry, next_index, results;
      entry = this.index_to_entry(index);
      results = [];
      while (counter < entry.orbit_length) {
        key = entry.key;
        next_index = this.hash(key, counter);
        next_entry = this.index_to_entry(next_index);
        if (index === next_entry.orbiton) {
          cat("  - ", next_index, " ", next_entry.key);
        }
        results.push(counter = 1 + counter);
      }
      return results;
    };

    HASH_TABLE.prototype.report = function() {
      var entry, index;
      console.log("\n");
      console.log("- hash_table-table report_used");
      index = 0;
      while (index < this.size) {
        entry = this.index_to_entry(index);
        if (entry.occured() && entry.no_collision()) {
          cat("  - ", index, " ", entry.key, " # ", entry.orbit_length);
          if (entry.used()) {
            cat("      ", entry.value);
          }
          this.report_orbit(index, 1);
        }
        index = 1 + index;
      }
      cat("\n");
      cat("- used : ", this.counter);
      return cat("- free : ", this.size - this.counter);
    };

    return HASH_TABLE;

  })();

  argack = new STACK();

  retack = new STACK();

  RETACK_POINT = (function() {
    function RETACK_POINT(array3) {
      this.array = array3;
      this.cursor = 0;
      this.local_variable_map = new Map();
    }

    RETACK_POINT.prototype.get_current_jo = function() {
      return this.array[this.cursor];
    };

    RETACK_POINT.prototype.at_tail_position = function() {
      return this.cursor + 1 === this.array.length;
    };

    RETACK_POINT.prototype.next = function() {
      return this.cursor = 1 + this.cursor;
    };

    return RETACK_POINT;

  })();

  eva_with_map = function(array, map) {
    var base_cursor, first_retack_point, jo, retack_point;
    base_cursor = retack.cursor();
    first_retack_point = new RETACK_POINT(array);
    first_retack_point.local_variable_map = map;
    retack.push(first_retack_point);
    while (retack.cursor() > base_cursor) {
      retack_point = retack.pop();
      jo = retack_point.get_current_jo();
      if (!retack_point.at_tail_position()) {
        retack_point.next();
        retack.push(retack_point);
      }
      eva_dispatch(jo, retack_point);
      argack.print();
    }
    return first_retack_point;
  };

  eva = function(array) {
    return eva_with_map(array, new Map());
  };

  eva_dispatch = function(jo, retack_point) {
    if (function_p(jo)) {
      return eva_primitive_function(jo, retack_point);
    } else if (jo === void 0) {

    } else if (!object_p(jo)) {
      return argack.push(jo);
    } else if (array_p(jo._sad)) {
      return retack.push(new RETACK_POINT(jo._sad));
    } else if (array_p(jo._into)) {
      return eva_into(jo._into, retack_point.local_variable_map);
    } else if (array_p(jo._out)) {
      return eva_out(jo._out, retack_point.local_variable_map);
    } else {
      return argack.push(jo);
    }
  };

  eva_primitive_function = function(jo, retack_point) {
    var arg_list, count_down, result;
    count_down = jo.length;
    arg_list = [];
    while (count_down !== 0) {
      arg_list.push(argack.pop());
      count_down = count_down - 1;
    }
    arg_list.reverse();
    result = jo.apply(this, arg_list);
    if (result !== void 0) {
      return argack.push(result);
    }
  };

  into = function() {
    var array, element, j, len;
    array = [];
    for (j = 0, len = arguments.length; j < len; j++) {
      element = arguments[j];
      array.push(element);
    }
    return {
      _into: array
    };
  };

  eva_into = function(array, local_variable_map) {
    var i, results;
    i = 0;
    results = [];
    while (i < array.length) {
      local_variable_map.set(array[(array.length - i) - 1], argack.pop());
      results.push(i = 1 + i);
    }
    return results;
  };

  out = function() {
    var array, element, j, len;
    array = [];
    for (j = 0, len = arguments.length; j < len; j++) {
      element = arguments[j];
      array.push(element);
    }
    return {
      _out: array
    };
  };

  eva_out = function(array, local_variable_map) {
    var fn, j, len, name_string, result, results;
    fn = function(name_string) {};
    results = [];
    for (j = 0, len = array.length; j < len; j++) {
      name_string = array[j];
      fn(name_string);
      result = local_variable_map.get(name_string);
      if (result === void 0) {
        results.push(orz("- in eva_out\n", "  meet undefined name : ", name_string));
      } else {
        results.push(argack.push(result));
      }
    }
    return results;
  };

  sad = function(array) {
    return {
      _sad: array
    };
  };

  drop = sad([into("1")]);

  dup = sad([into("1"), out("1", "1")]);

  over = sad([into("1", "2"), out("1", "2", "1")]);

  tuck = sad([into("1", "2"), out("2", "1", "2")]);

  swap = sad([into("1", "2"), out("2", "1")]);

  anp = function(bool1, bool2) {
    return bool1 && bool2;
  };

  orp = function(bool1, bool2) {
    return bool1 || bool2;
  };

  nop = function(bool) {
    return !bool;
  };

  va = function(string) {
    return {
      _va: string
    };
  };

  guard = function(array) {
    return {
      _guard: array
    };
  };

  antecedent_actual_length = function(antecedent) {
    var counter, index;
    index = 0;
    counter = 0;
    while (index < antecedent.length) {
      if ((object_p(antecedent[counter])) && (array_p(antecedent[counter]._guard))) {

      } else {
        counter = 1 + counter;
      }
      index = 1 + index;
    }
    return counter;
  };

  unify_array = function(source, pattern, map) {
    var index, success;
    index = 0;
    while (index < pattern.length) {
      success = unify_dispatch(source[index], pattern[index], map);
      if (success) {

      } else {
        return false;
      }
      index = 1 + index;
    }
    return map;
  };

  unify_dispatch = function(source, pattern, map) {
    var result;
    if (array_p(pattern)) {
      return unify_array(source, pattern, map);
    } else if (atom_p(pattern)) {
      if (source === pattern) {
        return map;
      } else {
        return false;
      }
    } else if (string_p(pattern._va)) {
      if (map.has(pattern._va)) {
        if (source === map.get(pattern._va)) {
          return map;
        } else {
          return false;
        }
      } else {
        map.set(pattern._va, source);
        return map;
      }
    } else if (array_p(pattern._guard)) {
      eva_with_map(pattern._guard, map);
      result = argack.pop();
      if (result) {
        return map;
      } else {
        return false;
      }
    } else {
      return orz("unify_dispatch fail\n", "source:", source, "\n", "pattern:", pattern, "\n", "map:", map);
    }
  };

  unify = function(source, pattern) {
    var result_map, success;
    result_map = new Map();
    success = unify_dispatch(source, pattern, result_map);
    if (success) {
      return result_map;
    } else {
      return false;
    }
  };

  match = function(sequent_array) {
    var antecedent, argument_array, index, length, new_retack_point, result_map, succedent;
    index = 0;
    while (index + 1 < sequent_array.length) {
      antecedent = sequent_array[index];
      succedent = sequent_array[index + 1];
      length = antecedent_actual_length(antecedent);
      argument_array = argack.n_tos(length);
      result_map = unify(argument_array, antecedent);
      if (result_map) {
        argack.n_pop(length);
        new_retack_point = new RETACK_POINT(succedent);
        new_retack_point.local_variable_map = result_map;
        retack.push(new_retack_point);
        return void 0;
      }
      index = 2 + index;
    }
    return orz("match fail\n", "sequent_array:", sequent_array);
  };

  get = function(array, index) {
    return array[index];
  };

  set = function(array, index, value) {
    array[index] = value;
    return void 0;
  };

  length = function(array) {
    return array.length;
  };

  concat = function(array1, array2) {
    return array1.concat(array2);
  };

  reverse = function(array) {
    var element, j, len, result;
    result = [];
    for (j = 0, len = array.length; j < len; j++) {
      element = array[j];
      result.push(element);
    }
    return result.reverse();
  };

  apply = function(array) {
    if (array.length === 0) {
      return void 0;
    } else {
      retack.push(new RETACK_POINT(array));
      return void 0;
    }
  };

  cond = function(sequent_array) {
    var antecedent, index, new_retack_point, result, succedent;
    index = 0;
    while (index + 1 < sequent_array.length) {
      antecedent = sequent_array[index];
      succedent = sequent_array[index + 1];
      eva(antecedent);
      result = argack.pop();
      if (result) {
        new_retack_point = new RETACK_POINT(succedent);
        retack.push(new_retack_point);
        return void 0;
      }
      index = 2 + index;
    }
    return orz("cond fail\n", "sequent_array:", sequent_array);
  };

  map = function(argument_array, function_array) {};

  ya = function(object, message) {
    var arg_length, arg_list, result;
    if (function_p(object[message])) {
      arg_length = object[message].length;
      arg_list = [];
      while (arg_length !== 0) {
        arg_list.push(argack.pop());
        arg_length = arg_length - 1;
      }
      arg_list.reverse();
      result = object[message].apply(object, arg_list);
      if (result !== void 0) {
        argack.push(result);
      }
    } else {
      argack.push(object[message]);
    }
    return void 0;
  };

  add = function(a, b) {
    return a + b;
  };

  sub = function(a, b) {
    return a - b;
  };

  mul = function(a, b) {
    return a * b;
  };

  div = function(a, b) {
    return a / b;
  };

  mod = function(a, b) {
    return a % b;
  };

  pow = function(a, b) {
    return Math.pow(a, b);
  };

  log = function(a, b) {
    return Math.log(a, b);
  };

  abs = function(a) {
    return Math.abs(a);
  };

  neg = function(a) {
    return -a;
  };

  max = function(a, b) {
    return Math.max(a, b);
  };

  min = function(a, b) {
    return Math.min(a, b);
  };

  eq = function(value1, value2) {
    return value1 === value2;
  };

  lt = function(value1, value2) {
    return value1 < value2;
  };

  gt = function(value1, value2) {
    return value1 > value2;
  };

  lteq = function(value1, value2) {
    return value1 <= value2;
  };

  gteq = function(value1, value2) {
    return value1 >= value2;
  };

  (function() {
    return eva([[3, dup, dup], [add, add], concat, apply, [], apply, [1, 2, 3], dup, reverse, dup, length, [4, 5, 6], dup, 1, 666, set, 666, 66, 1, [[2], [4, 5, 6], [666, 1], [4, 5, 6], [va("1"), guard([out("1"), 2, gt])], [out("1"), out("1"), out("1"), out("1")], [va("1"), guard([out("1"), 2, lt])], [out("1"), dup, add]], match, [[false], [321], [true], [123]], cond]);
  })();

}).call(this);
