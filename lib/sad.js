// Generated by CoffeeScript 1.10.0
(function() {
  var HASH_TABLE, HASH_TABLE_ENTRY, RETACK_POINT, STACK, abs, add, add1, andp, apply, argack, array_p, asr, atom_p, call_with_indentation, cat, cat_get_indentation_array, cat_indentation, concat, div, drop, dup, eq, eva, eva_dispatch, eva_into_local_variable, eva_out_local_variable, eva_primitive_function, function_p, get, gt, gteq, ifte, in_browser, in_node, incat, into, le, leeq, log, map, max, min, mod, mul, neg, object_p, orp, orz, out, over, pow, retack, sad, set, string_p, sub, sub1, swap, tuck, ya;

  in_node = function() {
    return typeof module !== "undefined";
  };

  in_browser = function() {
    return typeof window !== "undefined";
  };

  function_p = function(value) {
    return typeof value === "function";
  };

  array_p = function(value) {
    return Array.isArray(value);
  };

  object_p = function(value) {
    return (value instanceof Object) && (!(array_p(value))) && (!(value === null));
  };

  atom_p = function(value) {
    return !(array_p(value) || object_p(value));
  };

  string_p = function(value) {
    return typeof value === "string";
  };

  cat_indentation = 0;

  cat_get_indentation_array = function() {
    var i, result;
    result = [];
    i = 0;
    while (i < cat_indentation) {
      result.push(" ");
      i = 1 + i;
    }
    return result;
  };

  cat = function() {
    var argument, argument_array, j, len;
    argument_array = [];
    for (j = 0, len = arguments.length; j < len; j++) {
      argument = arguments[j];
      argument_array.push(argument);
    }
    if (in_node()) {
      return console.log.apply(console, cat_get_indentation_array().concat(argument_array));
    } else if (in_browser()) {
      return console.log.apply(console, argument_array);
    } else {
      return console.log.apply(console, cat_get_indentation_array().concat(argument_array));
    }
  };

  call_with_indentation = function(fun) {
    if (in_node()) {
      cat_indentation = 1 + cat_indentation;
      fun.call(this);
      return cat_indentation = cat_indentation - 1;
    } else if (in_browser()) {
      console.group();
      fun.call(this);
      return console.groupEnd();
    } else {
      cat_indentation = 1 + cat_indentation;
      fun.call(this);
      return cat_indentation = cat_indentation - 1;
    }
  };

  incat = function() {
    return call_with_indentation(function() {
      return cat.apply(this, arguments);
    });
  };

  orz = function() {
    cat.apply(this, arguments);
    return console.assert(false);
  };

  asr = function() {
    return console.assert.apply(console, arguments);
  };

  Array.prototype.last = function() {
    return this[this.length - 1];
  };

  STACK = (function() {
    function STACK() {
      this.array = [];
    }

    STACK.prototype.cursor = function() {
      return this.array.length;
    };

    STACK.prototype.set = function(index, value) {
      return this.array[index] = value;
    };

    STACK.prototype.get = function(index) {
      return this.array[index];
    };

    STACK.prototype.push = function(value) {
      return this.array.push(value);
    };

    STACK.prototype.pop = function() {
      return this.array.pop();
    };

    STACK.prototype.tos = function() {
      return this.array[this.array.length - 1];
    };

    STACK.prototype.push_array = function(array) {
      var j, len, results, value;
      results = [];
      for (j = 0, len = array.length; j < len; j++) {
        value = array[j];
        results.push(this.array.push(value));
      }
      return results;
    };

    STACK.prototype.n_pop = function(n) {
      var array;
      array = [];
      while (n > 0) {
        array.push(this.array.pop());
        n = n - 1;
      }
      return array.reverse();
    };

    STACK.prototype.n_tos = function(n) {
      var array;
      array = [];
      while (n > 0) {
        array.push(this.array[this.array.length - n]);
        n = n - 1;
      }
      return array.reverse();
    };

    STACK.prototype.is_empty = function() {
      return this.array.length === 0;
    };

    STACK.prototype.print = function() {
      var arg_list, index;
      index = 0;
      arg_list = [];
      while (index < this.cursor()) {
        arg_list.push(this.array[index]);
        index = 1 + index;
      }
      arg_list.unshift("  *", this.cursor(), "*  --");
      arg_list.push("--");
      return console.log.apply(console, arg_list);
    };

    return STACK;

  })();

  (function() {
    var array, testing_stack;
    testing_stack = new STACK();
    testing_stack.push(666);
    asr(testing_stack.pop() === 666);
    testing_stack.push_array([0, 1, 2]);
    array = testing_stack.n_pop(3);
    asr(array[0] === 0);
    asr(array[1] === 1);
    return asr(array[2] === 2);
  })();

  HASH_TABLE_ENTRY = (function() {
    function HASH_TABLE_ENTRY(index1) {
      this.index = index1;
      this.key = null;
      this.value = null;
      this.orbit_length = 0;
      this.orbiton = 0;
    }

    HASH_TABLE_ENTRY.prototype.occured = function() {
      return this.key !== null;
    };

    HASH_TABLE_ENTRY.prototype.used = function() {
      return this.value !== null;
    };

    HASH_TABLE_ENTRY.prototype.no_collision = function() {
      return this.index === this.orbiton;
    };

    return HASH_TABLE_ENTRY;

  })();

  HASH_TABLE = (function() {
    function HASH_TABLE(size, key_equal, hash) {
      var i;
      this.size = size;
      this.key_equal = key_equal;
      this.hash = hash;
      this.array = new Array(this.size);
      this.counter = 0;
      i = 0;
      while (i < this.size) {
        this.array[i] = new HASH_TABLE_ENTRY(i);
        i = 1 + i;
      }
    }

    HASH_TABLE.prototype.insert = function(key) {
      var counter, entry, index, orbit_entry, orbit_index;
      orbit_index = this.hash(key, 0);
      counter = 0;
      while (true) {
        index = this.hash(key, counter);
        entry = this.index_to_entry(index);
        if (!entry.occured()) {
          entry.key = key;
          entry.orbiton = orbit_index;
          orbit_entry = this.index_to_entry(orbit_index);
          orbit_entry.orbit_length = 1 + counter;
          this.counter = 1 + this.counter;
          return index;
        } else if (this.key_equal(key, entry.key)) {
          return index;
        } else if (counter === this.size) {
          return null;
        } else {
          counter = 1 + counter;
        }
      }
    };

    HASH_TABLE.prototype.search = function(key) {
      var counter, entry, index;
      counter = 0;
      while (true) {
        index = this.hash(key, counter);
        entry = this.index_to_entry(index);
        if (!entry.occured()) {
          return null;
        } else if (this.key_equal(key, entry.key)) {
          return index;
        } else if (counter === this.size) {
          return null;
        } else {
          counter = 1 + counter;
        }
      }
    };

    HASH_TABLE.prototype.key_to_index = function(key) {
      var index;
      index = this.insert(key);
      if (index !== null) {
        return index;
      } else {
        console.log("hash_table is filled");
        throw "hash_table is filled";
      }
    };

    HASH_TABLE.prototype.index_to_entry = function(index) {
      return this.array[index];
    };

    HASH_TABLE.prototype.key_to_entry = function(key) {
      return index_to_entry(key_to_index(key));
    };

    HASH_TABLE.prototype.report_orbit = function(index, counter) {
      var entry, key, next_entry, next_index, results;
      entry = this.index_to_entry(index);
      results = [];
      while (counter < entry.orbit_length) {
        key = entry.key;
        next_index = this.hash(key, counter);
        next_entry = this.index_to_entry(next_index);
        if (index === next_entry.orbiton) {
          cat("  - ", next_index, " ", next_entry.key);
        }
        results.push(counter = 1 + counter);
      }
      return results;
    };

    HASH_TABLE.prototype.report = function() {
      var entry, index;
      console.log("\n");
      console.log("- hash_table-table report_used");
      index = 0;
      while (index < this.size) {
        entry = this.index_to_entry(index);
        if (entry.occured() && entry.no_collision()) {
          cat("  - ", index, " ", entry.key, " # ", entry.orbit_length);
          if (entry.used()) {
            cat("      ", entry.value);
          }
          this.report_orbit(index, 1);
        }
        index = 1 + index;
      }
      cat("\n");
      cat("- used : ", this.counter);
      return cat("- free : ", this.size - this.counter);
    };

    return HASH_TABLE;

  })();

  argack = new STACK();

  retack = new STACK();

  RETACK_POINT = (function() {
    function RETACK_POINT(array3) {
      this.array = array3;
      this.cursor = 0;
      this.local_variable_map = new Map();
    }

    RETACK_POINT.prototype.get_current_jo = function() {
      return this.array[this.cursor];
    };

    RETACK_POINT.prototype.at_tail_position = function() {
      return this.cursor + 1 === this.array.length;
    };

    RETACK_POINT.prototype.next = function() {
      return this.cursor = 1 + this.cursor;
    };

    return RETACK_POINT;

  })();

  eva = function(array) {
    var base_cursor, first_retack_point, jo, retack_point;
    base_cursor = retack.cursor();
    first_retack_point = new RETACK_POINT(array);
    retack.push(first_retack_point);
    while (retack.cursor() > base_cursor) {
      retack_point = retack.pop();
      jo = retack_point.get_current_jo();
      if (!retack_point.at_tail_position()) {
        retack_point.next();
        retack.push(retack_point);
      }
      eva_dispatch(jo, retack_point);
      argack.print();
    }
    return first_retack_point;
  };

  eva_dispatch = function(jo, retack_point) {
    if (function_p(jo)) {
      return eva_primitive_function(jo, retack_point);
    } else if (jo === void 0) {

    } else if (!object_p(jo)) {
      return argack.push(jo);
    } else if (array_p(jo._sad)) {
      return retack.push(new RETACK_POINT(jo._sad));
    } else if (array_p(jo._into_local_variable)) {
      return eva_into_local_variable(jo._into_local_variable, retack_point.local_variable_map);
    } else if (array_p(jo._out_local_variable)) {
      return eva_out_local_variable(jo._out_local_variable, retack_point.local_variable_map);
    } else {
      return argack.push(jo);
    }
  };

  eva_primitive_function = function(jo, retack_point) {
    var arg_list, count_down, result;
    count_down = jo.length;
    arg_list = [];
    while (count_down !== 0) {
      arg_list.push(argack.pop());
      count_down = count_down - 1;
    }
    arg_list.reverse();
    result = jo.apply(this, arg_list);
    if (result !== void 0) {
      return argack.push(result);
    }
  };

  into = function() {
    var array, element, j, len;
    array = [];
    for (j = 0, len = arguments.length; j < len; j++) {
      element = arguments[j];
      array.push(element);
    }
    return {
      _into_local_variable: array
    };
  };

  eva_into_local_variable = function(array, local_variable_map) {
    var i, results;
    i = 0;
    results = [];
    while (i < array.length) {
      local_variable_map.set(array[(array.length - i) - 1], argack.pop());
      results.push(i = 1 + i);
    }
    return results;
  };

  out = function() {
    var array, element, j, len;
    array = [];
    for (j = 0, len = arguments.length; j < len; j++) {
      element = arguments[j];
      array.push(element);
    }
    return {
      _out_local_variable: array
    };
  };

  eva_out_local_variable = function(array, local_variable_map) {
    var fn, j, len, name_string, result, results;
    fn = function(name_string) {};
    results = [];
    for (j = 0, len = array.length; j < len; j++) {
      name_string = array[j];
      fn(name_string);
      result = local_variable_map.get(name_string);
      if (result === void 0) {
        results.push(orz("- in eva_out_local_variable\n", "  meet undefined name : ", name_string));
      } else {
        results.push(argack.push(result));
      }
    }
    return results;
  };

  sad = function(array) {
    return {
      _sad: array
    };
  };

  drop = sad([into("1")]);

  dup = sad([into("1"), out("1", "1")]);

  over = sad([into("1", "2"), out("1", "2", "1")]);

  tuck = sad([into("1", "2"), out("2", "1", "2")]);

  swap = sad([into("1", "2"), out("2", "1")]);

  andp = function(bool1, bool2) {
    return bool1 && bool2;
  };

  orp = function(bool1, bool2) {
    return bool1 || bool2;
  };

  get = function(array, index) {
    return array[index];
  };

  set = function(array, index, value) {
    return array[index] = value;
  };

  concat = function(array1, array2) {
    return array1.concat(array2);
  };

  apply = function(array) {
    retack.push(new RETACK_POINT(array));
    return void 0;
  };

  ifte = function(predicate_array, true_array, false_array) {};

  map = function(argument_array, function_array) {};

  ya = function(object, message) {
    var arg_length, arg_list, result;
    if (function_p(object[message])) {
      arg_length = object[message].length;
      arg_list = [];
      while (arg_length !== 0) {
        arg_list.push(argack.pop());
        arg_length = arg_length - 1;
      }
      arg_list.reverse();
      result = object[message].apply(object, arg_list);
      if (result !== void 0) {
        argack.push(result);
      }
    } else {
      argack.push(object[message]);
    }
    return void 0;
  };

  add = function(a, b) {
    return a + b;
  };

  sub = function(a, b) {
    return a - b;
  };

  add1 = function(a) {
    return a + 1;
  };

  sub1 = function(a) {
    return a - 1;
  };

  mul = function(a, b) {
    return a * b;
  };

  div = function(a, b) {
    return a / b;
  };

  mod = function(a, b) {
    return a % b;
  };

  pow = function(a, b) {
    return Math.pow(a, b);
  };

  log = function(a, b) {
    return Math.log(a, b);
  };

  abs = function(a) {
    return Math.abs(a);
  };

  neg = function(a) {
    return -a;
  };

  max = function(a, b) {
    return Math.max(a, b);
  };

  min = function(a, b) {
    return Math.min(a, b);
  };

  eq = function(value1, value2) {
    return value1 === value2;
  };

  le = function(value1, value2) {
    return value1 < value2;
  };

  gt = function(value1, value2) {
    return value1 > value2;
  };

  leeq = function(value1, value2) {
    return value1 <= value2;
  };

  gteq = function(value1, value2) {
    return value1 >= value2;
  };

  module.exports = {
    in_node: in_node,
    in_browser: in_browser,
    function_p: function_p,
    array_p: array_p,
    object_p: object_p,
    atom_p: atom_p,
    string_p: string_p,
    cat: cat,
    orz: orz,
    asr: asr,
    STACK: STACK,
    HASH_TABLE: HASH_TABLE,
    argack: argack,
    retack: retack,
    sad: sad,
    into: into,
    out: out,
    ya: ya,
    eva: eva
  };

}).call(this);
